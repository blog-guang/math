#include "matrix_market.h"

#include <fstream>
#include <iomanip>
#include <sstream>
#include <stdexcept>
#include <string>

namespace math {
namespace io {

// ── Header 解析 ─────────────────────────────────────────

static std::string toLower(std::string s) {
    for (auto& c : s) c = static_cast<char>(std::tolower(c));
    return s;
}

MMHeader MatrixMarket::parseHeader(std::istream& is) {
    // 第一行：banner
    std::string banner;
    if (!std::getline(is, banner)) {
        throw std::runtime_error("MatrixMarket: empty file");
    }
    if (banner.substr(0, 14) != "%%MatrixMarket") {
        throw std::runtime_error("MatrixMarket: invalid banner: " + banner);
    }

    // 解析 banner：%%MatrixMarket object format type symmetry
    std::istringstream bss(banner);
    std::string tag, object_str, format_str, type_str, sym_str;
    bss >> tag >> object_str >> format_str >> type_str >> sym_str;

    if (toLower(format_str) != "coordinate") {
        throw std::runtime_error(
            "MatrixMarket: only 'coordinate' format supported, got: " + format_str);
    }
    if (toLower(type_str) != "real") {
        throw std::runtime_error(
            "MatrixMarket: only 'real' type supported, got: " + type_str);
    }

    MMSymmetry sym = MMSymmetry::General;
    std::string sym_lower = toLower(sym_str);
    if (sym_lower == "symmetric") sym = MMSymmetry::Symmetric;
    else if (sym_lower == "skew-symmetric") sym = MMSymmetry::Skew_Symmetric;
    else if (sym_lower != "general") {
        throw std::runtime_error("MatrixMarket: unknown symmetry: " + sym_str);
    }

    // 跳过注释行（以 % 开头）
    std::string line;
    while (std::getline(is, line)) {
        if (line.empty()) continue;
        if (line[0] != '%') break;
    }

    // 当前 line 是尺寸行：rows cols nnz
    MMHeader header;
    std::istringstream hss(line);
    hss >> header.rows >> header.cols >> header.nnz;
    header.symmetry = sym;

    if (header.rows == 0 || header.cols == 0) {
        throw std::runtime_error("MatrixMarket: invalid dimensions");
    }

    return header;
}

// ── 读矩阵 ──────────────────────────────────────────────

SparseMatrix MatrixMarket::readMatrix(const std::string& filename) {
    std::ifstream file(filename);
    if (!file.is_open()) {
        throw std::runtime_error("MatrixMarket: cannot open file: " + filename);
    }

    MMHeader header = parseHeader(file);

    std::vector<size_t> rows, cols;
    std::vector<double> vals;
    rows.reserve(header.nnz);
    cols.reserve(header.nnz);
    vals.reserve(header.nnz);

    size_t r, c;
    double v;
    while (file >> r >> c >> v) {
        // 1-based → 0-based
        rows.push_back(r - 1);
        cols.push_back(c - 1);
        vals.push_back(v);

        // Symmetric/Skew-symmetric: 补充对称元素（非对角线）
        if (r != c) {
            if (header.symmetry == MMSymmetry::Symmetric) {
                rows.push_back(c - 1);
                cols.push_back(r - 1);
                vals.push_back(v);
            } else if (header.symmetry == MMSymmetry::Skew_Symmetric) {
                rows.push_back(c - 1);
                cols.push_back(r - 1);
                vals.push_back(-v);
            }
        }
    }

    return SparseMatrix::fromCOO(header.rows, header.cols, rows, cols, vals);
}

// ── 写矩阵 ──────────────────────────────────────────────

void MatrixMarket::writeMatrix(const std::string& filename,
                               SparseMatrix& matrix,
                               MMSymmetry symmetry)
{
    // 确保 COO 格式以便遍历
    matrix.toCOO();

    std::ofstream file(filename);
    if (!file.is_open()) {
        throw std::runtime_error("MatrixMarket: cannot open file for writing: " + filename);
    }

    // 对称矩阵写入时只写下三角（row >= col）
    std::vector<size_t> out_row, out_col;
    std::vector<double> out_val;

    const auto& rows = matrix.coo_row();
    const auto& cols = matrix.coo_col();
    const auto& vals = matrix.coo_val();

    for (size_t k = 0; k < vals.size(); ++k) {
        if (symmetry == MMSymmetry::General) {
            out_row.push_back(rows[k]);
            out_col.push_back(cols[k]);
            out_val.push_back(vals[k]);
        } else {
            // Symmetric / Skew-Symmetric: 只写 row >= col（下三角含对角）
            if (rows[k] >= cols[k]) {
                out_row.push_back(rows[k]);
                out_col.push_back(cols[k]);
                out_val.push_back(vals[k]);
            }
        }
    }

    // Banner
    std::string sym_str = "general";
    if (symmetry == MMSymmetry::Symmetric) sym_str = "symmetric";
    else if (symmetry == MMSymmetry::Skew_Symmetric) sym_str = "skew-symmetric";

    file << "%%MatrixMarket matrix coordinate real " << sym_str << "\n";
    file << "% Generated by math\n";
    file << matrix.rows() << " " << matrix.cols() << " " << out_val.size() << "\n";

    // 数据行（1-based 索引）
    file << std::setprecision(17);
    for (size_t k = 0; k < out_val.size(); ++k) {
        file << (out_row[k] + 1) << " " << (out_col[k] + 1) << " " << out_val[k] << "\n";
    }
}

// ── 读向量 ──────────────────────────────────────────────

Vector MatrixMarket::readVector(const std::string& filename) {
    std::ifstream file(filename);
    if (!file.is_open()) {
        throw std::runtime_error("MatrixMarket: cannot open vector file: " + filename);
    }

    std::string line;

    // 读 banner 或直接跳过注释
    while (std::getline(file, line)) {
        if (line.empty() || line[0] == '%') continue;
        break;  // 第一个非注释行 = 尺寸行
    }

    // 解析尺寸：N（或 N 1）
    size_t n, dummy;
    std::istringstream hss(line);
    hss >> n;
    hss >> dummy;  // 忽略可能存在的 "1"

    Vector v(n);
    for (size_t i = 0; i < n; ++i) {
        if (!(file >> v[i])) {
            throw std::runtime_error("MatrixMarket: unexpected end of vector file at index " +
                                     std::to_string(i));
        }
    }
    return v;
}

// ── 写向量 ──────────────────────────────────────────────

void MatrixMarket::writeVector(const std::string& filename, const Vector& vec) {
    std::ofstream file(filename);
    if (!file.is_open()) {
        throw std::runtime_error("MatrixMarket: cannot open vector file for writing: " + filename);
    }

    file << "%%MatrixMarket matrix array real general\n";
    file << "% Generated by math\n";
    file << vec.size() << " 1\n";
    file << std::setprecision(17);
    for (size_t i = 0; i < vec.size(); ++i) {
        file << vec[i] << "\n";
    }
}

}  // namespace io
}  // namespace math
